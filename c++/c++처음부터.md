1 byte = 8bit

둘다 1 byte
char -128 ~ 127
unsigned char 0 ~ 255

const 상수!

switch에서 break 위치 조정에 따라 case들을 묶을 수 있따.

inline 함수 => 여러번 호출되는 작은 함수인 경우, 인수와 리턴값을 전달하는 시간이 실행시간보다 긴 경우 => 컴파일러가 코드를 통째로 써넣어 전체적인 속도 향상!

함수 프로토타입 선언 =>  형 이름 (인수 리스트)

기본 인수는 오른쪽부터 맞추어야 한다. 


함수 오버로드! <=> 함수의 형과 개수가 다르면 같은 이름을 가진 함수를 여러 개 정의할 수 있다.
하나라도 같으면 컴퓨터가 구분하지 못한다!

template => 다루는 형을 제외한 다른 요소가 완전히 동일한 함수를 단 한번만 정의할 수 있다.             


reference 활용하기 A를 인수로 받으면 복제품이지만 rA는 A의 복제품이 아닌 원본 그대로를 받게됨.


함수에 배열을 인자로 받을 경우 넣을 때는 첫번째 요소이 주소로 즉 배열의 이름만 넣으면 된다. 포인터의 주소로 넣을 수도 있다. 

문자열은 char의 배열로 이루어져 있다. Hello => H e l l o \0 => \0은 문자열의 마지막을 나타냄. 즉 문자열의 길이 +1
문자열은 char str[] = "hello"로 초기화가 가능하지만 대입은 되지 않는다.
but 문자열을 배열이 아닌 char의 포인터로 초기화 하면 추가적인 대입이 가능.

char* str = "hello";
str = "goodbye";
가능!!


동일 이름의 지역변수가 있는 상황에서 전역변수 쓰고 싶으면 ::a로 사용.

지역 변수에 static을 붙이면 전역 변수와 같은 기억수명을 가지게 된다. but 전역 변수는 모든 파일에서 사용가능하지만 정직ㅇ느 그 파일 안에서만 사용이 가능.

지역변수, 함수 인자는 stack에 저장.
전역 변수, static은 정적메모리에 저장
동적은 힙에 저장.


    cin.tie(NULL); => 입력과 출력 분리 즉 입력에 따라 출력이 바로 아니고 입력 다 받고나서 출력나오게

    ios_base::sync_with_stdio(false) => c형식의 입출력이랑 동기화 되도록. but 우리는 c++표준입력 cin, cout만 쓸거여서 false로

    endl vs \n => endl은 개행줄 만이 아니라 출력버퍼를 비우는 역할까지 한ㄷ.